---
title: "codigoTFG"
author: "Jorge de Andrés"
date: "12 de enero de 2019"
output:
  pdf_document: default
  html_document:
    df_print: paged
  word_document: default
always_allow_html: yes
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

```

Borramos el environment lo primero para siempre tenerlo limpio en la ejecución:

```{r clean_environment}

rm(list=ls())

```

Importamos todas las librerías que vamos a ir necesitando:

```{r librerías, echo=TRUE, results='hide'}

#install.packages("ggplot2")
#install.packages("caret")
#install.packages("plyr")
#install.packages("wordcloud")
#install.packages("hexbin")
#install.packages("RColorBrewer")
#install.packages("corrplot")
#install.packages("FactoMineR")
#devtools::install_github("kassambara/factoextra")
#install.packages("factoextra")
#install.packages("nnet")
#install.packages("plotly")
#install.packages("class")
#install.packages("gmodels")
#install.packages("randomForest")
#install.packages("e1071")
#install.packages("ape")
#install.packages("cluster")
#install.packages("fpc")

library("ggplot2")
library("caret")
library("plyr")
library("wordcloud")
library("hexbin")
library("RColorBrewer")
library("corrplot")
library("FactoMineR")
library("factoextra")
library("nnet")
library("plotly")
library("class")
library("gmodels")
library("randomForest")
library("e1071")
library("ape")
library("cluster")
library("fpc")


```


Lo primero que tengo que hacer es importar el dataset que he creado
```{r importar_dataset}

dataset <- read.csv("datos.txt", header = TRUE)

```


Ahora lo que hago es pasarlo a una matriz, quitando tanto el nombre (que no me interesa) como la etiqueta (que no la necesito por ahora)

```{r creacion_matrices}

matriz.pacientes.etiquetas <- dataset[, -1]
matriz.pacientes.datos <- matriz.pacientes.etiquetas[, -25]

```

# Análisis Exploratorio

Primero compruebo que todos los datos tienen un tipo correcto.

```{r comprobacion_tipo_datos}

sapply(matriz.pacientes.datos, class)

```

Veo la media de la edad de los pacientes y el rango en el que se mueve

```{r datos_edad}

mean(matriz.pacientes.datos[, 1])
range(matriz.pacientes.datos[, 1])

```

 Voy a ver estos datos gráficamente:
 
```{r grafico_estadistica_edad}

qplot(1, matriz.pacientes.datos[, 1], xlab = "Pacientes", ylab = "Edad", geom="boxplot")

pdf("Imágenes Obtenidas/boxplotEdadPacientes.pdf")

qplot(1, matriz.pacientes.datos[, 1], xlab = "Pacientes", ylab = "Edad", geom="boxplot")

dev.off

```
 
 
 Finalmente, veo un resúmen de cada columna
 
```{r summary_toda_matriz}

summary(matriz.pacientes.datos)

```
 

Como se puede ver, los datos de los pacientes están muy distanciados, y además su media es muy alta.
Así, la media de la edad difiere enormemente del resto de valores de la matriz.
Debido a ello, debemos de hacer un preprocesado de los datos del problema.

# Preparación de los datos

Como he comentado antes, Lo que voy a hacer ahora es un centrado y escalado de los datos de la matriz. De esta manera, la red neuronal no tendrá ningún valor que destaque especialmente y con ello no dará de inicio más peso a unos valores que a otros, ya que no lo buscamos.

Ahora hacemos un centrado y escalado de los datos, ya que la edad no sigue el rango del resto de valores, y distorsionaría la predicción

```{r centrado_escalado}

preObjeto <- preProcess(matriz.pacientes.datos, method=c("center", "scale"))  # Quiero hacer un centrado y escalado
matriz.pacientes.datos.centscal <- predict(preObjeto, matriz.pacientes.datos) # Obtengo los valores en la matriz centscal

```


Después del preprocesado, aunque con los datos no preprocesados, voy a hacer la visualización de algunas relaciones entre variables, de tal manera que podamos ver gráficamente algunos aspectos interesantes:

## Visualización de Datos

Para empezar voy a sacar una nube de palabras para mostrar los nombres más comúnes en los datos facilitados:

```{r wordcloud_nombres_preparacion, echo=T, results="hide"}

# Lo primero que tengo que hacer es contar la frecuencia de los nombres

dataNombres <- ddply(dataset,.(nom),nrow)
dataNombres <- dataNombres[order(dataNombres$V1, decreasing = TRUE), ]

```
Una vez que tengo los nombres contados y ordenados, es el momento de crear la WordCloud

```{r wordcloud}

set.seed(9999) # Para el mantenimiento del mismo patrón

wordcloud(words = dataNombres$nom, freq = dataNombres$V1, min.freq = 1, random.order=FALSE, rot.per=0.5, colors=c("Orange","Purple","Pink", "Red", "Yellow", "Green", "Blue", "Black"))

pdf("Imágenes Obtenidas/wordcloudNombresPacientes.pdf")

wordcloud(words = dataNombres$nom, freq = dataNombres$V1, min.freq = 1, random.order=FALSE, rot.per=0.5, colors=c("Orange","Purple","Pink", "Red", "Yellow", "Green", "Blue", "Black"))

dev.off

```


Ahora voy a sacar un plot para ver la relación entre la edad y el sexo de las personas que están en consulta

```{r grafico_edad_sexo}

plot(matriz.pacientes.datos[,1], matriz.pacientes.datos[,2], xlab="Edad", ylab="Sexo (0 - mujer, 1 - hombre)", main="Edad & Sexo")

pdf("Imágenes Obtenidas/GráficoEdad-Sexo.pdf")

plot(matriz.pacientes.datos[,1], matriz.pacientes.datos[,2], xlab="Edad", ylab="Sexo (0 - mujer, 1 - hombre)", main="Edad & Sexo")

dev.off

```


Otro plot para ver la correlación entre ser agresivo y ser impulsivo

```{r grafico_agresivo_impulsivo}

rf <- colorRampPalette(rev(brewer.pal(4,'Spectral')))
df <- data.frame(matriz.pacientes.datos[, 23], matriz.pacientes.datos[, 24])
h <- hexbin(df)
plot(h, colramp=rf, xlab="Agresivo", ylab="Impulsivo", main="Agresivo Vs Impulsivo")

pdf("Imágenes Obtenidas/GraficoAgresivoVsImpulsivo.pdf")

plot(h, colramp=rf, xlab="Agresivo", ylab="Impulsivo", main="Agresivo Vs Impulsivo")

dev.off

```

Otro plot similar para ver la relación de ser inhibido e impulsivo

```{r grafico_inhibido_impulsivo}

df <- data.frame(matriz.pacientes.datos[, 21], matriz.pacientes.datos[, 24])
h <- hexbin(df)
plot(h, colramp=rf, xlab="Inhibido", ylab="Impulsivo", main="Inhibido Vs Impulsivo")

pdf("Imágenes Obtenidas/GraficoInhibidoVsImpulsivo.pdf")

plot(h, colramp=rf, xlab="Inhibido", ylab="Impulsivo", main="Inhibido Vs Impulsivo")

dev.off

```

Voy a ver la relación entre el razonamiento emocional (actuar según tus sentimientos) y la impulsividad

```{r grafico_razEm_Impulsivo}

df <- data.frame(matriz.pacientes.datos[, 20], matriz.pacientes.datos[, 24])
h <- hexbin(df)
plot(h, colramp=rf, xlab="Razonamiento Emocional", ylab="Impulsivo", main="Razonamiento Emocional Vs Impulsivo")

pdf("Imágenes Obtenidas/GraficoRazonamientoEmocionalVsImpulsivo.pdf")

plot(h, colramp=rf, xlab="Razonamiento Emocional", ylab="Impulsivo", main="Razonamiento Emocional Vs Impulsivo")

dev.off

```

Ahora quiero sacar una relación entre ser agresivo y ver el grupo en el que están

```{r grafico_agresivo_grupo}

rf <- colorRampPalette(rev(brewer.pal(4,'Spectral')))
df <- data.frame(matriz.pacientes.datos[, 23], matriz.pacientes.etiquetas[, 25])
h <- hexbin(df)
plot(h, colramp=rf, xlab="Agresivo", ylab="Grupo", main="Agresivo Y Grupo Real")

pdf("Imágenes Obtenidas/GraficoAgresivoVsGrupo.pdf")

plot(h, colramp=rf, xlab="Agresivo", ylab="Grupo", main="Agresivo Y Grupo Real")

dev.off

```

Voy a hacer lo mismo con la impulsividad

```{r grafico_impulsivo_grupo}

rf <- colorRampPalette(rev(brewer.pal(4,'Spectral')))
df <- data.frame(matriz.pacientes.datos[, 24], matriz.pacientes.etiquetas[, 25])
h <- hexbin(df)
plot(h, colramp=rf, xlab="Impulsivo", ylab="Grupo", main="Impulsivo y Grupo Real")

pdf("Imágenes Obtenidas/GraficoImpulsivoVsGrupo.pdf")

plot(h, colramp=rf, xlab="Impulsivo", ylab="Grupo", main="Impulsivo y Grupo Real")

dev.off

```

De estas gráficas estamos obteniendo información realmente interesante antes de la predicción de los datos.
He preferido hacer gráficas en 2D porque las gráficas en 3D son mucho más difíciles de interpretar que estas bonitas gráficas en 2D

Vamos a ver la correlación que tienen mis variables 

```{r calculo_correlacion}

res <- cor(matriz.pacientes.datos[, 1:24], method = "spearman") # Por mi tipo de datos, hacemos la correlación por spearman
options(width = 100)
res.round <- round(res, 2)

```

Como saca una tabla enorme, lo que voy a hacer es usar una librería que me da una función para sacar de una forma bonita las correlaciones entre las variables.

```{r grafico_correlaciones_variables}

corrplot(res.round, method="circle")

# Lo exporto a PDF para que se pueda ver mejor

pdf("Imágenes Obtenidas/Corrplot.pdf")
corrplot(res.round, method="circle")
dev.off

```

Como podemos ver, por ejemplo, resiliencia baja y media tienen una correlación de -1, ya que si hay una no hay la otra y viceversa.
Esto pasa igual con las relaciones entre contexto, ya que buena - trauma, trauma - mala, mala - buena tienen que ser inversas.

Ahora voy a sacar un PCA para ver la importancia de las variables:

Para los cálculos, uso la matriz con el centrado y escalado ya hechos

```{r PCA_Calculations}

resultado.pca <- PCA(matriz.pacientes.datos.centscal, graph = FALSE)
#Con la siguiente línea podemos ver que podemos hacer con esto calculado
print(resultado.pca)

```
Nos interesa ver los eigenvalues, que son los que presentarán la cantidad de varianza que aportan las variables:

```{r table_eigenvalues_PCA}

eigenvalues.PCA <- resultado.pca$eig
eigenvalues.PCA

```
Como se puede comprobar, de las 24 variables (componentes) que tenemos, la mitad de la varianza la conseguimos con aproximadamente 5 variables.
También se puede ver que a parti de las 17 variables prácticamente no hay un aumento de la varianza.
En el caso de un problema grande, sería interesante la eliminación de algunas de las variables, para dejar un dataset más pequeño con el que poder trabajar. En nuestro caso, nuestro problema es pequeño, y además las variables están escogidas a mano, por lo que no haré una reducción del dataset.

Ahora, para completar este apartado de PCA, lo que voy a hacer es sacar la gráfica de la varianza acumulada con los valores anteriores:

```{r PCA_eigenvalues_graph}

plotPCA <- fviz_screeplot(resultado.pca, ncp=24)
plot(plotPCA)

pdf("Imágenes Obtenidas/GraficoEigenvalues.pdf")
plot(plotPCA)
dev.off

```

Ahora voy a sacar un "Factor Map" de las variables. Esto lo puedo hacer gracias a las coordenadas que me da una de las variables tras hacer el PCA.
Así, voy primero a ver la tabla y luego voy a sacar el mapa:

```{r PCA_Coordinates}

resultado.pca$var$coord

```
Como se puede ver, me está poniendo mis 24 variables en 5 dimensiones, con unas coordenadas concretas. Ahora, lo que voy a hacer, es representarlo.
Con esta representación podré sacar algunas conclusiones:

```{r PCA_Coordinates_Graph}

fviz_pca_var(resultado.pca)

# Lo exporto a PDF para mejor visualización

pdf("Imágenes Obtenidas/GraficoVectoresVariablesPCA.pdf")
fviz_pca_var(resultado.pca)
dev.off

```

Con esto puedo sacar conclusiones al igual que con el gran gráfico de correlaciones de variables, solo que esta representación está intencionada para más de 2 dimensiones.

Puedo ver algunas de las conclusiones fáciles que saqué anteriormente, como que resiliencia media es contraria a baja, o que la relación con el contexto de trauma y mala son contrarias a buena.

Otras relaciones también puedo ver, como que los deberías y el razonamiento emocional parecen ser ciertamente contrarios, o que el filtro mental no depende de prácticamente nada ya que está en todo el centro.

También es importante ver como, mediante dos componentes principales (dos dimensiones), solo estoy explicando un del 30,2% del total, lo que es muy poco. Por unirlo con los gráficos anteriores, estas dos componentes que se han elegido como x e y son las dos variables que más varianza (y por lo tanto, explicación) tenían en el gráfico de barras anterior.


Ahora mi siguiente paso es sacar un gráfico de los individuos, para ver donde están colocados en este sistema:

```{r coordenadas_individuos}

head(resultado.pca$ind$coord) # Solo saco los primeros para no ocupar demasiado espacio

```

Ahora, tras ver que todos mis individuos tienen unas ciertas coordenadas, vamos a representarlos gráficamente:

```{r plot_coordendas_individuos}

fviz_pca_ind(resultado.pca)

pdf("Imágenes Obtenidas/GraficoIndividuosPCA.pdf")
fviz_pca_ind(resultado.pca)
dev.off

```
Se puede ver que la mayoría de los pacientes están en torno al centro, mientras que tenemos un outlayer, que es el número 27.

***

# Modelos de Inteligencia Artificial supervisados


Ahora lo que hago es coger un conjunto muy grande de los datos para hacer el entrenamiento

```{r creación_conjunto_entrenamiento}

conjuntoEntrenamiento <- sample(1:67, 55)

```


###############################################################
#################### 1 NEURONA ################################
###############################################################


Lo que voy a hacer ahora es entrenar la red neuronal con diferente cantidad de neuronas,y voy a ir comparando el resultado...

###################### SIN SOFTMAX #############################

```{r 1_neurona, echo=TRUE, results='hide'}

dataframe.resultados.1neu <- data.frame(Ent_1Neu = numeric(),
                                        Test_1Neu = numeric())

for(i in 1:20)
{
  pacientes.1neu <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=1)

  #Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
  
  pacientes.prediccion.1neu <- predict( pacientes.1neu, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.1neu) # Vemos las probabilidades de pertenencia de cada valor
  
  # Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
  
  pacientes.prediccion.1neu.class <- apply( pacientes.prediccion.1neu, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.1neu.class
  
  # Lo visualizo en forma de tabla para ir viendo el error
  
  table( pacientes.prediccion.1neu.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  #Calculo el acierto
  
  acierto.ent.teorico.1neu <- sum( diag( table( pacientes.prediccion.1neu.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  #TEST
  
  pacientes.prediccion.test.1neu <- predict( pacientes.1neu, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.1neu
  
  pacientes.prediccion.test.1neu.class <- apply( pacientes.prediccion.test.1neu, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.1neu.class
  
  table( pacientes.prediccion.test.1neu.class , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.test.teorico.1neu <- sum( diag( table( pacientes.prediccion.test.1neu.class, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  dataframe.pasada <- data.frame(Ent_1Neu = acierto.ent.teorico.1neu,
                                 Test_1Neu = acierto.test.teorico.1neu)
  
  dataframe.resultados.1neu <- rbind(dataframe.resultados.1neu, dataframe.pasada)

}


```


Lo voy a entrenar también con el SOFTMAX = true. Esto optimiza la verosimilitud, no el error cuadrático medio...
###################### CON SOFTMAX ##############################

```{r 1_neurona_SOFTMAX, echo=TRUE, results='hide'}

dataframe.resultados.1neu.soft <- data.frame(Ent_1Neu_soft = numeric(),
                                             Test_1Neu_soft = numeric())

for(i in 1:20)
{
  pacientes.1neu.softmax <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=1, softmax = T )

  #Una vez que lo tengo entrenado, lo que voy a hacer es calcular el error tanto en el entrenamiento como en el test de cada uno
  
  pacientes.prediccion.1neu.softmax <- predict( pacientes.1neu.softmax, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.1neu.softmax) # Vemos las probabilidades de pertenencia de cada valor
  
  # Ahora que los tengo todos entrenados, Determinamos cual es la máxima, es decir, la clase a la que hay que asignar los objetos
  
  pacientes.prediccion.1neu.class.softmax <- apply( pacientes.prediccion.1neu.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.1neu.class.softmax
  
  # Lo visualizo en forma de tabla para ir viendo el error
  
  table( pacientes.prediccion.1neu.class.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  #Calculo el acierto
  
  acierto.ent.teorico.1neu.soft <- sum( diag( table( pacientes.prediccion.1neu.class.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  #TEST
  
  pacientes.prediccion.test.1neu.softmax <- predict( pacientes.1neu.softmax, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.1neu.softmax
  
  pacientes.prediccion.test.1neu.class.softmax <- apply( pacientes.prediccion.test.1neu.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.1neu.class.softmax
  
  table( pacientes.prediccion.test.1neu.class.softmax , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.test.teorico.1neu.soft <- sum( diag( table( pacientes.prediccion.test.1neu.class.softmax, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  dataframe.pasada <- data.frame(Ent_1Neu_soft = acierto.ent.teorico.1neu.soft,
                                 Test_1Neu_soft = acierto.test.teorico.1neu.soft)
  
  dataframe.resultados.1neu.soft <- rbind(dataframe.resultados.1neu.soft ,dataframe.pasada)
  
}


```



###############################################################
#################### 2 NEURONAS ###############################
###############################################################

A partir de ahora voy a hacer exactamente lo mismo, por lo que haré chunks más grandes para evitar una sobrecarga de chunks, y reduciré la cantidad de comentarios, ya que serán redundantes

###################### SIN SOFTMAX #############################

```{r 2_neuronas, echo=TRUE, results='hide'}

dataframe.resultados.2neu <- data.frame(Ent_2Neu = numeric(),
                                        Test_2Neu = numeric())

for(i in 1:20)
{

  pacientes.2neu <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=2 )
  
  pacientes.prediccion.2neu <- predict( pacientes.2neu, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.2neu) # Vemos las probabilidades de pertenencia de cada valor
  
  pacientes.prediccion.2neu.class <- apply( pacientes.prediccion.2neu, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.2neu.class
  
  
  table( pacientes.prediccion.2neu.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  acierto.teorico.entrenamiento.2neu <- sum( diag( table( pacientes.prediccion.2neu.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  # TEST
  
  pacientes.prediccion.test.2neu <- predict( pacientes.2neu, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.2neu
  
  pacientes.prediccion.test.2neu.class <- apply( pacientes.prediccion.test.2neu, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.2neu.class
  
  table( pacientes.prediccion.test.2neu.class , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.2neu <- sum( diag( table( pacientes.prediccion.test.2neu.class, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_2Neu = acierto.teorico.entrenamiento.2neu,
                                 Test_2neu = acierto.teorico.test.2neu)
  
  dataframe.resultados.2neu <- rbind(dataframe.resultados.2neu, dataframe.pasada)
  
  
}

```


###################### CON SOFTMAX ##############################

```{r 2_neuronas_SOFTMAX, echo=TRUE, results='hide'}

dataframe.resultados.2neu.soft <- data.frame(Ent_2Neu_soft = numeric(),
                                             Test_2Neu_soft = numeric())

for(i in 1:20)
{

  pacientes.2neu.softmax <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=2, softmax = T )
  
  pacientes.prediccion.test.2neu.softmax <- predict( pacientes.2neu.softmax, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.test.2neu.softmax)
  
  pacientes.prediccion.test.2neu.class.softmax <- apply( pacientes.prediccion.test.2neu.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.2neu.class.softmax
  
  table( pacientes.prediccion.test.2neu.class.softmax , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.ent.2neu.softmax <- sum( diag( table( pacientes.prediccion.test.2neu.class.softmax, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  # TEST
  
  pacientes.prediccion.test.2neu.softmax <- predict( pacientes.2neu.softmax, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.2neu.softmax
  
  pacientes.prediccion.test.2neu.class.softmax <- apply( pacientes.prediccion.test.2neu.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.2neu.class.softmax
  
  table( pacientes.prediccion.test.2neu.class.softmax , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.2neu.softmax <- sum(diag(table(pacientes.prediccion.test.2neu.class.softmax, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_2Neu_soft = acierto.teorico.ent.2neu.softmax,
                                 Test_2neu_soft = acierto.teorico.test.2neu.softmax)
  
  dataframe.resultados.2neu.soft <- rbind(dataframe.resultados.2neu.soft, dataframe.pasada)
}

```



###############################################################
#################### 3 NEURONAS ###############################
###############################################################

###################### SIN SOFTMAX #############################

```{r 3_neuronas, echo=TRUE, results='hide'}

dataframe.resultados.3neu <- data.frame(Ent_3Neu = numeric(),
                                        Test_3Neu = numeric())

for(i in 1:20)
{

  pacientes.3neu <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=3)
  
  pacientes.prediccion.3neu <- predict( pacientes.3neu, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.3neu) # Vemos las probabilidades de pertenencia de cada valor
  
  
  pacientes.prediccion.3neu.class <- apply( pacientes.prediccion.3neu, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.3neu.class
  
  
  table( pacientes.prediccion.3neu.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  
  acierto.teorico.entrenamiento.3neu <- sum( diag( table( pacientes.prediccion.3neu.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  # TEST
  
  pacientes.prediccion.test.3neu <- predict( pacientes.3neu, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.3neu
  
  pacientes.prediccion.test.3neu.class <- apply( pacientes.prediccion.test.3neu, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.3neu.class
  
  table( pacientes.prediccion.test.3neu.class , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.3neu <- sum( diag( table( pacientes.prediccion.test.3neu.class, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_3Neu = acierto.teorico.entrenamiento.3neu,
                                 Test_3neu = acierto.teorico.test.3neu)
  
  dataframe.resultados.3neu <- rbind(dataframe.resultados.3neu, dataframe.pasada)
}

```


###################### CON SOFTMAX ##############################

```{r 3_neuronas_SOFTMAX, echo=TRUE, results='hide'}

dataframe.resultados.3neu.soft <- data.frame(Ent_3Neu_soft = numeric(),
                                             Test_3Neu_soft = numeric())

for(i in 1:20)
{

  pacientes.3neu.softmax <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=3, softmax = T)
  
  pacientes.prediccion.3neu.softmax <- predict( pacientes.3neu.softmax, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.3neu.softmax) # Vemos las probabilidades de pertenencia de cada valor
  
  
  pacientes.prediccion.3neu.class.softmax <- apply(pacientes.prediccion.3neu.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.3neu.class.softmax
  
  
  table( pacientes.prediccion.3neu.class.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  
  acierto.teorico.ent.3neu.softmax <- sum( diag( table( pacientes.prediccion.3neu.class.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  #TEST
  
  pacientes.prediccion.test.3neu.softmax <- predict( pacientes.3neu.softmax, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.3neu.softmax
  
  pacientes.prediccion.test.3neu.class.softmax <- apply( pacientes.prediccion.test.3neu.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.3neu.class.softmax
  
  table( pacientes.prediccion.test.3neu.class.softmax , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.3neu.softmax <- sum( diag( table( pacientes.prediccion.test.3neu.class.softmax, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_3Neu_soft = acierto.teorico.ent.3neu.softmax,
                                 Test_3neu_soft = acierto.teorico.test.3neu.softmax)
  
  dataframe.resultados.3neu.soft <- rbind(dataframe.resultados.3neu.soft, dataframe.pasada)
}

```



###############################################################
#################### 3 NEURONAS ###############################
###################  Con Decay  ###############################
###############################################################

###################### SIN SOFTMAX #############################

```{r 3_neuronas_decay, echo=TRUE, results='hide'}

dataframe.resultados.3neu.decay <- data.frame(Ent_3Neu_decay = numeric(),
                                              Test_3Neu_decay = numeric())

for(i in 1:20)
{

  pacientes.3neu.decay <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=3, decay = 0.2)
  
  pacientes.prediccion.3neu.decay <- predict( pacientes.3neu.decay, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.3neu.decay) # Vemos las probabilidades de pertenencia de cada valor
  
  
  pacientes.prediccion.3neu.class.decay <- apply( pacientes.prediccion.3neu.decay, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.3neu.class.decay
  
  
  table( pacientes.prediccion.3neu.class.decay, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  
  acierto.teorico.ent.3neu.decay <- sum( diag( table( pacientes.prediccion.3neu.class.decay, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  #TEST
  
  pacientes.prediccion.test.3neu.decay <- predict( pacientes.3neu.decay, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.3neu.decay
  
  pacientes.prediccion.test.3neu.class.decay <- apply( pacientes.prediccion.test.3neu.decay, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.3neu.class.decay
  
  table( pacientes.prediccion.test.3neu.class.decay , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.3neu.decay <- sum( diag( table( pacientes.prediccion.test.3neu.class.decay, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_3Neu_decay = acierto.teorico.ent.3neu.decay,
                                 Test_3neu_decay = acierto.teorico.test.3neu.decay)
  
  dataframe.resultados.3neu.decay <- rbind(dataframe.resultados.3neu.decay, dataframe.pasada)
  
}
  
  

```


###################### CON SOFTMAX ##############################

```{r 3_neuronas_decay_SOFTMAX, echo=TRUE, results='hide'}

dataframe.resultados.3neu.decay.softmax <- data.frame(Ent_3Neu_decay_sf = numeric(),
                                                      Test_3Neu_decay_sf = numeric())

for(i in 1:20)
{

  pacientes.3neu.decay.softmax <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=3, softmax = T, decay = 0.03)
  
  pacientes.prediccion.3neu.decay.softmax <- predict( pacientes.3neu.decay.softmax, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.3neu.decay.softmax) # Vemos las probabilidades de pertenencia de cada valor
  
  
  pacientes.prediccion.3neu.class.decay.softmax <- apply( pacientes.prediccion.3neu.decay.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.3neu.class.decay.softmax
  
  
  table( pacientes.prediccion.3neu.class.decay.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  
  acierto.teorico.ent.3neu.decay.sf <- sum( diag( table( pacientes.prediccion.3neu.class.decay.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  # TEST
  
  pacientes.prediccion.test.3neu.decay.softmax <- predict( pacientes.3neu.decay.softmax, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.3neu.decay.softmax
  
  pacientes.prediccion.test.3neu.class.decay.softmax <- apply( pacientes.prediccion.test.3neu.decay.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.3neu.class.decay.softmax
  
  table( pacientes.prediccion.test.3neu.class.decay.softmax , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.3neu.decay.sf <- sum( diag( table( pacientes.prediccion.test.3neu.class.decay.softmax, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_3Neu_decay_sf = acierto.teorico.ent.3neu.decay.sf,
                                 Test_3neu_decay_sf = acierto.teorico.test.3neu.decay.sf)
  
  dataframe.resultados.3neu.decay.softmax <- rbind(dataframe.resultados.3neu.decay.softmax, dataframe.pasada)
}
  

```


###############################################################
#################### 5 NEURONAS ###############################
###############################################################

###################### SIN SOFTMAX #############################

```{r 5_neuronas, echo=TRUE, results='hide'}

dataframe.resultados.5neu <- data.frame(Ent_5Neu = numeric(),
                                        Test_5Neu = numeric())

for(i in 1:20)
{

  pacientes.5neu <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=5 )
  
  pacientes.prediccion.5neu <- predict( pacientes.5neu, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.5neu) # Vemos las probabilidades de pertenencia de cada valor
  
  pacientes.prediccion.5neu.class <- apply( pacientes.prediccion.5neu, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.5neu.class
  
  table( pacientes.prediccion.5neu.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  acierto.teorico.entrenamiento.5neu <- sum( diag( table( pacientes.prediccion.5neu.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  #TEST
  
  pacientes.prediccion.test.5neu <- predict( pacientes.5neu, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.5neu
  
  pacientes.prediccion.test.5neu.class <- apply( pacientes.prediccion.test.5neu, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.5neu.class
  
  table( pacientes.prediccion.test.5neu.class , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.5neu <- sum( diag( table( pacientes.prediccion.test.5neu.class, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_5Neu = acierto.teorico.entrenamiento.5neu,
                                 Test_5neu = acierto.teorico.test.5neu)
  
  dataframe.resultados.5neu <- rbind(dataframe.resultados.5neu, dataframe.pasada)
  
}



```


###################### CON SOFTMAX ##############################

```{r 5_neuronas_SOFTMAX, echo=TRUE, results='hide'}

dataframe.resultados.5neu.soft <- data.frame(Ent_5Neu_soft = numeric(),
                                             Test_5Neu_soft = numeric())

for(i in 1:20)
{

  pacientes.5neu.softmax <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=5, softmax = T )
  
  pacientes.prediccion.5neu.softmax <- predict( pacientes.5neu.softmax, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.5neu.softmax) # Vemos las probabilidades de pertenencia de cada valor
  
  pacientes.prediccion.5neu.class.softmax <- apply( pacientes.prediccion.5neu.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.5neu.class.softmax
  
  table( pacientes.prediccion.5neu.class.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  acierto.teorico.ent.5neu.softmax <- sum( diag( table( pacientes.prediccion.5neu.class.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  # TEST
  
  pacientes.prediccion.test.5neu.softmax <- predict( pacientes.5neu.softmax, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.5neu.softmax
  
  pacientes.prediccion.test.5neu.class.softmax <- apply( pacientes.prediccion.test.5neu.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.5neu.class.softmax
  
  table( pacientes.prediccion.test.5neu.class.softmax, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.5neu.softmax <- sum( diag( table( pacientes.prediccion.test.5neu.class.softmax, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_5Neu_soft = acierto.teorico.ent.5neu.softmax,
                                 Test_5neu_soft = acierto.teorico.test.5neu.softmax)
  
  dataframe.resultados.5neu.soft <- rbind(dataframe.resultados.5neu.soft, dataframe.pasada)
}


```



###############################################################
#################### 5 NEURONAS ###############################
#################### CON DECAY  ###############################
###############################################################

###################### SIN SOFTMAX #############################

```{r 5_neuronas_decay, echo=TRUE, results='hide'}

dataframe.resultados.5neu.decay <- data.frame(Ent_5Neu_decay = numeric(),
                                              Test_5Neu_decay = numeric())

for(i in 1:20)
{

  pacientes.5neu.decay <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=5, decay=0.1)
  
  pacientes.prediccion.5neu.decay <- predict( pacientes.5neu.decay, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.5neu.decay) # Vemos las probabilidades de pertenencia de cada valor
  
  pacientes.prediccion.5neu.decay.class <- apply( pacientes.prediccion.5neu.decay, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.5neu.decay.class
  
  table( pacientes.prediccion.5neu.decay.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  acierto.teorico.ent.5neu.decay <- sum( diag( table( pacientes.prediccion.5neu.decay.class, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  # TEST
  
  pacientes.prediccion.test.decay.5neu <- predict( pacientes.5neu.decay, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.decay.5neu
  
  pacientes.prediccion.test.decay.5neu.class <- apply( pacientes.prediccion.test.decay.5neu, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.decay.5neu.class
  
  table( pacientes.prediccion.test.decay.5neu.class , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.5neu.decay <- sum( diag( table( pacientes.prediccion.test.decay.5neu.class, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_5Neu_decay = acierto.teorico.ent.5neu.decay,
                                 Test_5neu_decay = acierto.teorico.test.5neu.decay)
  
  dataframe.resultados.5neu.decay <- rbind(dataframe.resultados.5neu.decay, dataframe.pasada)
  
}



```


###################### CON SOFTMAX ##############################

```{r 5_neuronas_decay_SOFTMAX, echo=TRUE, results='hide'}

dataframe.resultados.5neu.decay.softmax <- data.frame(Ent_5Neu_decay_sf = numeric(),
                                                      Test_5Neu_decay_sf = numeric())

for(i in 1:20)
{


  pacientes.5neu.decay.softmax <- nnet( matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], class.ind( matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) , size=5, softmax = T, decay = 0.05)
  
  pacientes.prediccion.5neu.decay.softmax <- predict( pacientes.5neu.decay.softmax, matriz.pacientes.datos.centscal[conjuntoEntrenamiento, 1:24], type="raw" )
  head(pacientes.prediccion.5neu.decay.softmax) # Vemos las probabilidades de pertenencia de cada valor
  
  pacientes.prediccion.5neu.decay.class.softmax <- apply( pacientes.prediccion.5neu.decay.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.5neu.decay.class.softmax
  
  table( pacientes.prediccion.5neu.decay.class.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] )  # Lo vemos en forma de tabla.
  
  acierto.teorico.ent.5neu.decay.sf <- sum( diag( table( pacientes.prediccion.5neu.decay.class.softmax, matriz.pacientes.etiquetas[conjuntoEntrenamiento, 25] ) ) )/55 # Esta cuenta nos da el índice de acierto
  
  # TEST
  
  pacientes.prediccion.test.decay.5neu.softmax <- predict( pacientes.5neu.decay.softmax, matriz.pacientes.datos.centscal[-conjuntoEntrenamiento, 1:24], type="raw" )
  pacientes.prediccion.test.decay.5neu.softmax
  
  pacientes.prediccion.test.decay.5neu.class.softmax <- apply( pacientes.prediccion.test.decay.5neu.softmax, MARGIN=1, FUN='which.is.max')
  pacientes.prediccion.test.decay.5neu.class.softmax
  
  table( pacientes.prediccion.test.decay.5neu.class.softmax , matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] )
  acierto.teorico.test.5neu.decay.sf <- sum( diag( table( pacientes.prediccion.test.decay.5neu.class.softmax, matriz.pacientes.etiquetas[-conjuntoEntrenamiento, 25] ) ) )/12
  
  
  dataframe.pasada <- data.frame(Ent_5Neu_decay_sf = acierto.teorico.ent.5neu.decay.sf,
                                 Test_5neu_decay_sf = acierto.teorico.test.5neu.decay.sf)
  
  dataframe.resultados.5neu.decay.softmax <- rbind(dataframe.resultados.5neu.decay.softmax, dataframe.pasada)
  
}

```


Ahora lo que hay que hacer es unir todos los resultados:

```{r join_resultados_perceptron}

dataframe.resultados.perceptron <- cbind(dataframe.resultados.1neu,
                                         dataframe.resultados.1neu.soft,
                                         dataframe.resultados.2neu,
                                         dataframe.resultados.2neu.soft,
                                         dataframe.resultados.3neu,
                                         dataframe.resultados.3neu.soft,
                                         dataframe.resultados.3neu.decay,
                                         dataframe.resultados.3neu.decay.softmax,
                                         dataframe.resultados.5neu,
                                         dataframe.resultados.5neu.soft,
                                         dataframe.resultados.5neu.decay,
                                         dataframe.resultados.5neu.decay.softmax)

remove(dataframe.resultados.1neu)
remove(dataframe.resultados.1neu.soft)
remove(dataframe.resultados.2neu)
remove(dataframe.resultados.2neu.soft)
remove(dataframe.resultados.3neu)
remove(dataframe.resultados.3neu.soft)
remove(dataframe.resultados.3neu.decay)
remove(dataframe.resultados.3neu.decay.softmax)
remove(dataframe.resultados.5neu)
remove(dataframe.resultados.5neu.soft)
remove(dataframe.resultados.5neu.decay)
remove(dataframe.resultados.5neu.decay.softmax)

```

Ahora visualizamos los mejores resultados de cada entrenamiento:

```{r analisis_resultados_perceptron}

head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_1Neu,          decreasing = T), 1:2])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_1Neu_soft,     decreasing = T), 3:4])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_2neu,          decreasing = T), 5:6])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_2neu_soft,     decreasing = T), 7:8])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_3neu,          decreasing = T), 9:10])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_3neu_soft,     decreasing = T), 11:12])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_3neu_decay,    decreasing = T), 13:14])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_3neu_decay_sf, decreasing = T), 15:16])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_5neu,          decreasing = T), 17:18])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_5neu_soft,     decreasing = T), 19:20])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_5neu_decay,    decreasing = T), 21:22])
head(dataframe.resultados.perceptron[order(dataframe.resultados.perceptron$Test_5neu_decay_sf, decreasing = T), 23:24])

```


# Obtención de Resultados de Perceptrón

Importo los datos:

```{r importacion_datos_resultados_finales}

dataset.resultados <- read.csv2("Resultados.txt")

```

Ahora voy a sacar un gráfico interactivo donde comparo los resultados.


```{r grafico_resultados_interactivo}

tipos = dataset.resultados[, 1]
real = dataset.resultados[, 2]
practico = dataset.resultados[, 3]

p <- plot_ly(dataset.resultados, x = ~tipos, y = ~real, type = 'bar', name = 'Real') %>% add_trace(y = ~practico, name = 'Práctico') %>% layout(yaxis = list(title = 'Porcentaje'), barmode = 'group')

p 
#Mostramos el gráfico interactivo

```

Ahora que hemos sacado los resultados obtenidos con el perceptrón multicapa, vamos con otras técnicas supervisadas:

## KNN


Hacemos nuevos conjuntos:

```{r nuevos_conjuntos_para_KNN}

# Para hacer la predicción con knn, voy a coger los grupos de una manera distinta:

conjuntoEntrenamiento = matriz.pacientes.datos.centscal[1:55, 1:24]
conjuntoTest = matriz.pacientes.datos.centscal[56:67, 1:24] # Utilizo por supuesto la matriz de centrado y escalado

etiquetasEntrenamiento = matriz.pacientes.etiquetas[1:55, 25]
etiquetasTest = matriz.pacientes.etiquetas[56:67, 25]

```

Si quisiéramos mostrar los conjuntos de entrenamiento y de test...

```{r conjuntos_knn, eval=FALSE}

conjuntoEntrenamiento
conjuntoTest
etiquetasEntrenamiento
etiquetasTest

```


Comenzamos las pruebas. Como sabemos, normalmente el mejor valor de K para KNN suele ser el valor que más se acerque a la raíz cuadrada del total de los valores. Por eso, empezaremos por K = 8:

### Para K = 8...

```{r knn_8}

prediccion.knn.8 <- knn(train = conjuntoEntrenamiento, test = conjuntoTest, cl = etiquetasEntrenamiento, k = 8)
prediccion.knn.8

```

Sacamos crosstable:

```{r crosstable_8}
CrossTable(x = etiquetasTest , y = prediccion.knn.8, prop.chisq = FALSE)
```


### Para K = 6

```{r}

prediccion.knn.6 <- knn(train = conjuntoEntrenamiento, test = conjuntoTest, cl = etiquetasEntrenamiento, k = 6)
prediccion.knn.6

```

Obtenemos la crosstable:

```{r crosstable_6}

CrossTable(x = etiquetasTest , y = prediccion.knn.6, prop.chisq = FALSE)

```


### Para k = 10

```{r knn_10}

prediccion.knn.10 <- knn(train = conjuntoEntrenamiento, test = conjuntoTest, cl = etiquetasEntrenamiento, k = 10)
prediccion.knn.10

```

Obtenemos la crosstable:

```{r crosstable_10}

CrossTable(x = etiquetasTest , y = prediccion.knn.10, prop.chisq = FALSE)

```

### Como se puede observar, la mejor predicción la hemos hecho con K = 8



## Random Forest

Ahora voy a implementar una solución mediante Random Forest:


```{r seed_randomforest, echo=T, results="hide"}

set.seed(1000) #Pongo una seed para reproducibilidad

```

Una vez instalado e importado, lo que tengo que hacer es crear el Random Forest, y ejecutarlo...

```{r randomforest}

model <- randomForest(as.factor(dataset[, 26]) ~ ., data = dataset[, 2:25], importance = TRUE, ntree = 300)
model

```
Aquí podemos ver la matriz de confusión, de la que obtenemos también el fallo por clases.

El Out-Of-Bag es un método de estimación de error que se usa en algunos algoritmos como Random Forest, y usa el modelo de Bagging para hacer muestras de submuestras usadas para el entrenamiento.
El OOB es el error de predidcción medio de cada una de las muestras de entrenamiento.

Bagging es un meta-algoritmo usado para aumentar la estabilidad y precisión de algoritmos de Machine Learning de clasificación y regresión.

Vemos que el valor OOB (Out-Of-the-Bag) es una valor muy alto, de alrededor del 50%, por lo que nuestro modelo no está prediciendo bien.

Ahora obtenemos el número de árboles que necesitamos realmente, y la importancia de las variables en este modelo:

```{r importance_graphs_RF}

plot(model, main="Random Forest")

varImpPlot(model, main = "Random Forest - MDA y Gini") # Gracias a importance = true

# Lo exporto a PDF para mejor visualización

pdf("Imágenes Obtenidas/ResultadosRandomForest.pdf")
plot(model, main="Random Forest")
varImpPlot(model, main = "Random Forest - MDA y Gini")
dev.off


```

Vamos a interpretar estos datos del modelo:

+ MeanDecreaseAccuracy se refiere al decremento de la exactitud del modelo si se permutan los valores en cada característica. En otras palabras, MDA nos muestra la media de valores que se clasificarían mal si se quitara esa característica de la predicción. Por ello, eliminar elementos coo la impulsividad o la pseudo-resiliencia sería fatal para el modelo, mientras que la eliminación de relación con el contexto mala, pensamiento dicotómico o generalización excesiva parece ser que mejorarían el sistema.

+ MeanDecreaseGini se refiere a la medida de la ganancia media de pureza mediante la división de cierta variable. Cuanto más importante sea la variable, habrá un mayor descenso en el Gini. La importancia de este está íntimamente relacionada a la función de decisión local, que Random Forest usa para seleccionar cual es la mejor separación.
Debido a esto, estamos viendo que la edad, la impulsividad y la pseudo-responsabilidad son valores que tienen un gran descenso en Gini, lo cual significa que Random Forest ha determinado que eran de gran importancia.

Un elemento que me gustaría destacar es que el modelo está bastante regularizado y es bastante robusto, ya que casi todas las variables son bastante resistentes a las permutaciones, y por lo tanto no tienen un peso extremo a la hora de tomar decisiones, a excepción de la impulsividad.


Ahora, para probar a ver si hay diferencia, en vez del dataset normal voy a usar el dataset centrado y escalado, para ver si el OOB desciende:

```{r creacion_df_centscal_grupo_randomforest}

# primero añado el grupo a la matriz, creando una nueva

matriz.pacientes.datos.centscal.grupo <- cbind(matriz.pacientes.datos.centscal, dataset$grupo)
colnames(matriz.pacientes.datos.centscal.grupo)[25] <- "grupo"

```

Ahora entrenamos el nuevo modelo:

```{r randomforest_centscal}

model_centscal <- randomForest(as.factor(grupo) ~ ., data = matriz.pacientes.datos.centscal.grupo, importance = TRUE, ntree = 200)
model_centscal

```

Podemos ver que obtenemos lo mismo.
Vamos a ver si también obtenemos lo mismo en los grafos de importancia:

```{r importance_graphs_RF_centscal}

plot(model_centscal, main="Random Forest Con Centrado y Escalado")

varImpPlot(model_centscal, main="Random Forest con Centrado y Escalado - MDA y Gini") # Gracias a importance = true

# Lo exporto de nuevo a PDF

pdf("Imágenes Obtenidas/ResultadosRandomForestCentScal.pdf")
plot(model_centscal, main="Random Forest Con Centrado y Escalado")
varImpPlot(model_centscal, main="Random Forest con Centrado y Escalado - MDA y Gini")
dev.off

```

En este caso, el MDA me dice que el sexo es la gran lacra de este modelo, mientras que la impulsividad sigue siendo el factor más determinante para acertar.
Del Gini obtengo resultados similares.

Ahora, ya que hemos visto que cambiando el dataset no mejoramos el modelo, lo que vamos a hacer es, con el primer dataset, quitar las columnas que en el MDA tengan un valor negativo, de tal manera que la precisión del modelo debería de aumentar.


```{r improving_dataset_rf}

# Las columnas que son una mayor lacra son las siguientes: Relación Contexto Mala, Pensamiento dicotómico, generalización excesiva, sexo, razonamiento emocional, deberías, asertivo, relación-contexto buena, etiquetado, relación contexto trauma.

dataset.randomforest <- dataset[ , c(-1, -3, -4, -5, -6, -13, -14, -15, -20, -23)]
head(dataset.randomforest)

```

Ahora que tenemos el dataset creado, vamos a hacer la predicción de nuevo:

```{r randomforest_new_dataset}

model_new <- randomForest(as.factor(grupo) ~ ., data = dataset.randomforest, importance = TRUE, ntree = 200)
model_new

```

Vamos a ver ahora ls gráficos...

```{r importance_graphs_RF_new}

plot(model_new, main="Random Forest Nuevo")

varImpPlot(model_new, main = "Random Forest Nuevo - MDA y Gini") 

# Lo volvemos a exportar

pdf("Imágenes Obtenidas/ResultadosRandomForestMejorado.pdf")
plot(model_new, main="Random Forest Nuevo")
varImpPlot(model_new, main = "Random Forest Nuevo - MDA y Gini") 
dev.off


```

Como se puede observar, ahora hay nuevas variables que "lastran" el resultado del Random Forest.
De todas maneras, hemos conseguido una bajada del 50% de media en OOB Error al 45% de media en OOB Error (entrenando), lo cual es una disminución menos notable de lo esperado, pero es una disminución.


Ahora lo voy a hacer con 10 fold X Validation:

```{r randomforest_10F-XValidation}

result <- rfcv(dataset[, 2:26], as.factor(dataset$grupo), cv.fold=10)
head(result)

```

Podemos ver el error, bajo la variable $error.cv, y podemos ver las predicciones que se han hecho para cada una de las n.var.


## SVM de Kernel Lineal

Lo bueno que tiene SVM es que es muy robusto frente a la dimensión, por lo que deberíamos de obtener a priori buenos resultados con este método.

Con este método no necesito tener un conjunto de entrenaminento y otro de test, por lo que sigo adelante.

Ahora que hemos instalado la librería, vamos a crear el SVM:

```{r creacion_modelo_svm}

modelo.svm <- svm(matriz.pacientes.datos.centscal, as.factor(dataset[, 26]), kernel = "linear") # Al poner los grupos como factor, estoy consiguiendo que no sean continuos para el modelo, sino "discretos", ya que los factor no son valores que puedan ser continuos. Con esto consigo una clasificación.
summary(modelo.svm)

```
Como vemos en el resumen, tenemos una C-Classification (necesitamos clasificar), con kernel lineal, y 58 vectores soporte.

Ahora que tenemos creado este primer modelo, toca predecir:

```{r prediccion_svm}

prediccion <- predict(modelo.svm, matriz.pacientes.datos.centscal)
prediccion

```

Ahora que hemos predicho, tenemos que sacar la matriz de confusión:

```{r matriz_confusion_svm_Acierto}

matriz.conf <- table(prediccion, dataset[ ,26])
matriz.conf
sum(diag(matriz.conf))/67

```

## SVM de Kernel RBF

```{r creacion_modelo_svm_RBF}

modelo_svm.radial <- svm(matriz.pacientes.datos.centscal, as.factor(dataset[, 26]), kernel="radial")
summary(modelo_svm.radial)

```
Aquí tenemos una C-Classification (necesaria para clasificar), con Kernel esta vez radial y 66 vectores soporte.

Ahora que tenemos creado este primer modelo, toca predecir:

```{r prediccion_modelo_svm_RBF}

prediccion.radial <- predict(modelo_svm.radial, matriz.pacientes.datos.centscal)
prediccion.radial

```

Ahora que hemos predicho, tenemos que sacar la matriz de confusión:

```{r matriz_confusion_svm_RBF_Acierto}

matriz.conf.radial <- table(prediccion.radial, dataset[,26])
matriz.conf.radial
sum(diag(matriz.conf.radial))/67

```

 
### Como vemos, nos movemos en valores superiores al 75% de acierto

Por lo tanto, SVM es una buena técnica para la predicción en este problema.

***

Ahora pasamos a los modelos de inteligencia artificial no supervisados:

# Modelos de inteligencia artificial no supervisados

El primer modelo de inteligencia artificial no supervisado que voy a usar es un modelo de clustering llamado Dendrograma.

## Dendrograma

Para esto, lo que voy a hacer es dividirlo en 4 clusters, coincidiendo con los 4 grupos de trastornos que tengo.


```{r creacion_clusters_dendrograma}

dd <- dist(scale(dataset[,2:25]), method = "euclidean") #Nos basamos en la distancia euclídea
hier.clust <- hclust(dd, method = "ward.D2")
colores.dendrograma <- c("red", "orange", "green", "black") # Creamos los colores con los que queremos el cluster
cluster.4 <- cutree(hier.clust, 4) # Cluster jerárquico de 4...

png("dendrograma_pacientes.png")
plot(as.phylo(hier.clust), type = "fan", tip.color = colores.dendrograma[cluster.4], label.offset = 0.3, cex = 0.8) #Lo pintamos
dev.off()

```

Como vemos, estamos obteniendo el indentificador de cada paciente en el dendrograma, donde los pacientes que mas se parecen estarán más juntos, mientras que los que menos se parecen estarán más separados.
Es interesante analizar como los pacientes verdes y los naranjas surgen de la misma salida del centro, cosa que no ocurre con los rojos y los negros, lo cual quiere decir que algo tienen en común estos dos tipos de casos.


Ahora voy a hacer el mismo dendrograma pero con el DataSet de centrado y escalado, de tal manera que veamos a ver si hay diferencias:

```{r creacion_clusters_dendrograma_centradoEscalado}

dd <- dist(scale(matriz.pacientes.datos.centscal), method = "euclidean")
hier.clust <- hclust(dd, method = "ward.D2")
colores.dendrograma <- c("red", "orange", "green", "black")
cluster.4 <- cutree(hier.clust, 4)
plot(as.phylo(hier.clust), type = "fan", tip.color = colores.dendrograma[cluster.4], label.offset = 0.3, cex = 0.8)

# Ahora la exporto a pdf
pdf("dendrograma_pacientes.pdf")
plot(as.phylo(hier.clust), type = "fan", tip.color = colores.dendrograma[cluster.4], label.offset = 0.3, cex = 0.8)
dev.off()

```

Si lo comparamos, vemos que hemos obtenido exactamente el mismo resultado, por lo que en este caso el centrado y escalado no es necesario.

## K-Means

El algoritmo KMeans en principio no es el algoritmo más adecuado para este trabajo, ya que se basa en círculos para la clasificación de los individuos, cuando en principio en mis datos esto no es así. De todas formas, voy a clasificar a los pacientes siguiendo este algoritmo para comprobar la eficacia que tiene sobre mi problema:

Hacemos el clustering y vemos algunos resultados:

```{r k-means}

datos.kmeans <- matriz.pacientes.datos # Sin la clasificación dentro del dataset

clusters <- kmeans(datos.kmeans, centers=4)
clusters$centers

clusters$cluster

```

Interpretando estos resultados, obtenemos:

+ El cluster 1 destaca por sexo más hacia masculino que otros, una relación contexto ciertamente buena, una educación permisiva, una resiliencia baja, maximización y minimización, razonamiento emocional, cierta inhibición y poca agresividad.

+ El cluster 2 destaca por una edad mayor, es el cluster con mejor relación con el contexto, y suelen tener las personas de este cluster una educación normal. Destaca por una resiliencia media, pensamiento dicotómico, generalización excesiva, etiquetado, conclusiones arbitrarias, deberías, razonamiento emocional e inhibición.

+ El cluster número 3 destaca por tener una edad aún más elevada, más ratio de personas del sexo femenino que ningún otro cluster, y tienen una relación con el contexto bastante variable. La educación de estas personas es principalmente normal, con una resiliencia que puede ser tanto baja como media. Destacan por el pensamiento dicotómico, generalización excesiva, poco etiquetado, maximización y minimización, filtro mental, conclusiones arbitrarias, pseudoresponsabilidad, deberías, y suelen ser bastante inhibidos e impulsivos.

+ Finalmente, el cluster 4 destaca por ser el que tiene la edad más elevada y el ratio de sexo más masculino. La relación con el contexto de estos individuos clasificados en este grupo es principalmente de trauma, aunque también hay buenas y malas. La educación de estos individuos es principalmente permisiva, y la resiliciencia tiende a media. Destacan por la poca etiquetación que hacen, pero un gran fitro mental, conclusiones arbitrarias, poca pseudo-responsabilidad, muchos deberías, poco razonamiento emocional, y son principalmente inhibidos e impulsivos.


Ahora sacamos la gráfica para poder ver como los ha clasificado sobre dos componentes principales artificiales:

```{r plots_k-means}

# Representado sobre las dos componentes principales que más explicación nos dan de las variables

clusplot(datos.kmeans, clusters$cluster, color = TRUE, main = "Representación 2D con Clusplot", labels = 4, xlab = "Comp 1", ylab = "Comp 2") 

# Ahora la siguiente representación será con componentes discriminantes, que son las dos dimensiones sobre las que la representación de datos es más linealmente separable respecto a la predicción de grupos que ha hecho KMeans

plotcluster(datos.kmeans, clusters$cluster)


# Ahora lo voy a exportar a pdf para una mejor visualización

pdf("Imágenes Obtenidas/ResultadosKmeans.pdf")
clusplot(datos.kmeans, clusters$cluster, color = TRUE, main = "Representación 2D con Clusplot", labels = 4, xlab = "Comp 1", ylab = "Comp 2") 
plotcluster(datos.kmeans, clusters$cluster)
dev.off

```


